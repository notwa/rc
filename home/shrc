#!/usr/bin/env false
# for busybox ash, dash, bash, and zsh.

umask 022
unset FANCY; _=: && [ -z $_ ] && FANCY=1 || FANCY=0 # detect bash, osh, and zsh
if [ "$FANCY" = 0 ]; then . ~/.prep; fi # handle stuff like /etc/profile and $PATH

__f() { ! return 1; } && __g() { return 256; } && is_zsh() { __f && ! __g; }
if is_zsh && case $- in (im|ilm) :;; (?*) ! :;; (*) :; esac then emulate zsh
setopt histverify rcquotes histsavenodups chaselinks braceccl extendedglob \
histignorespace histreduceblanks alwaystoend noflowcontrol pathdirs nobeep \
promptpercent autopushd normstarsilent completealiases notify sharehistory \
histignoredups kshtypeset nopromptsubst completeinword histexpiredupsfirst \
menucomplete autocd; fi # in the event that .zshrc did not source at startup

__prepare() {
pl() { printf %s\\n "$@"; } && die() { pl >&2 "prepare: $*"; exit 1; } || exit
set +efu && unset CDPATH IFS && trap 'echo /dev/null' INT EXIT || die bad shell
mkdirs() { for d; do [ -d "$d" ] || mkdir "$d" || die 'failed to mkdir'; done; }
if [ "${HOME#/}" = "$HOME" ] || ! cd -- "$HOME"; then # rare but disastrous case
for HOME in /root /home/* -; do [ -d "$HOME" ] && [ -O "$HOME" ] && break; done
[ -n "$HOME" ] || HOME="$(mktemp -d)" && cd -- "${HOME:-/fail}" || die 'no home'
fi && mkdirs "$HOME" "${XDG_CACHE_HOME:="$HOME/.cache"}" "$XDG_CACHE_HOME/shrc"
cache="$XDG_CACHE_HOME/shrc/sh-$$" || die readonly # TODO: use shell name again!
pl '#!/usr/bin/env false' 'preload=:' > "$cache" || die 'failed to create cache'
printf %s "$cache" && trap - INT EXIT && exec >> "$cache" || die 'what the fuck'
if combo="$HOME/sh/recombine" && [ -s "$combo" ]; then . "$combo" || exit
else pl 'printf >&2 %s\\n "prepare: missing recombination script"'; fi &&
pl 'unset preload' && if [ -n "${cache##*\'*}" ]; then pl "rm -- '$cache'"; fi
}

. "$(__prepare)" || printf >&2 %s\\n "prepare: source returned failure"
[ -z "$preload" ] || printf >&2 %s\\n "prepare: script ended abruptly"

# {{{1 core utilities

pl() { printf '%s\n' "$@"; } ### @ pl - print each argument on its own line.
refresh() { hash -r; } ### @ refresh - invoke `hash -r`.
have() { if is_zsh; then whence -p -- "$1"; else which -- "$1"; fi; } 2>/dev/null
has() { have "$@"; } >/dev/null

if has sudo; then
    doas() {
        printf >&2 '\033[7m %s \033[m\n' 'warning: you ran sudo when you meant doas!'
        sudo "$@"
    }
elif has doas; then
    sudo() {
        printf >&2 '\033[7m %s \033[m\n' 'warning: you ran doas when you meant sudo!'
        doas "$@"
    }
fi

BADPATH() { printf >&2 'ADDPATH: %s\n' "$2"; return "$1"; }

ADDPATH() { ### @- append a directory to `$PATH` if it isn't already present.
    [ $# = 1 ] || BADPATH 64 "expected exactly 1 argument, got $#" || return
    [ -n "$1" ] || BADPATH 64 "path cannot be empty" || return
    if ! __NEWPATH="$(CDPATH= 2>&1 cd -- "${1:?}" && pwd -P)"; then
        ! is_zsh || __NEWPATH="${__NEWPATH%: *}" # zsh appends it
        BADPATH 66 "$1: ${__NEWPATH##*: }" || return # steal the error message
    fi
    set -- "$__NEWPATH" "$1" && unset __NEWPATH || return
    [ "${1%:*}" = "$1" ] || BADPATH 64 "path contains colons: %s $1" || return
    case ":$PATH:" in (::) PATH="$1";; (*":$1:"*) :;; (*) PATH="$PATH:$1"; esac
}

ROPATH() {
    [ $# = 0 ] || { printf >&2 'ROPATH: expected exactly 0 arguments, got %s\n' $#; return 64; }
    local segment= previous= newpath= oldpath="$PATH:"
    while segment="${oldpath%%:*}"; [ "$segment" != "$oldpath" ]; do
        [ -z "$segment" ] || [ -z "$previous" ] || newpath="$newpath$previous:"
        [ -z "$segment" ] || previous="$segment"
        oldpath="${oldpath#*:}"
    done
    [ -z "$previous" ] || printf 'rotated %s\n' "$previous" >&2
    [ -z "$previous" ] || newpath="$previous:$newpath"
    export PATH="${newpath%:}"
}

# {{{1 configurations

if [ -d "$HOME/opt/local/bin" ]; then
    printf 'Warning: You have a %s directory\n         consider moving it to %s\n' \
      '~/opt/local/bin' '~/.local/bin' >&2
    ADDPATH "$HOME/opt/local/bin"
else
    ADDPATH "$HOME/.local/bin"
fi

# clean up problematic, potentially-inherited exports:
unset PREFIX CC CPP CXX LD CFLAGS CPPFLAGS CXXFLAGS LDFLAGS
unset AR RANLIB RC WINDRES OBJDUMP OBJCOPY
unset LD_LIBRARY_PATH
unset CDPATH # grief.

[ "$DESKTOP_SESSION" != xfce ] || export QT_QPA_PLATFORMTHEME="" # unhide menu bar
#[ "$TERM" != vt102 ] || export TERM="xterm" # PuTTY over serial
export EA_AUTH="auth"
export EA_DIR="t"
export EA_DOMAIN="https://eaguru.guru"
export EDITOR=vim
export ENV="$HOME/.shrc" # for dash and ash
export LESS='-QRSci'
export PAGER=less
export PYTHONIOENCODING=utf-8 # damnit python!
export SSH_AUTH_SOCK=0 # more info: https://0x0.st/NUnw
export TZ=':/etc/localtime' # more info: https://0x0.st/NUnv

# $LANG has been my bane whenever i forget to set it properly, so check it.
if [ "$LANG" != "en_US.UTF-8" ] && [ "$LANG" != "en_CA.UTF-8" ]; then
    if [ -z "$MSYSTEM" ] || [ "$LANG" != "C.UTF-8" ]; then
        printf 'Warning: LANG is %s\n' "${LANG:-empty!}" >&2
    fi
fi
