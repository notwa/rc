echo START.PROFILE
[ -e /etc/profile ] && emulate sh -c "source /etc/profile"
echo FINISH.PROFILE

# trace:
# /etc/zsh/zshenv{.zwc,}
# ~/.zshenv{.zwc,}
# /etc/zsh/zshrc{.zwc,}

HISTFILE=~/.histfile
HISTSIZE=99999
SAVEHIST=99999
TIMEFMT=$'\e[93m%*U/%*E cpu/real (%P), %MM mem:\e[36m %J\e[0m'
DIRSTACKSIZE=24

setopt always_to_end            # Move cursor to the end of a completed word.
setopt append_history
setopt share_history            # across sessions
setopt auto_cd                  # exec a dir to cd
setopt auto_list                # Automatically list choices on ambiguous completion.
setopt auto_menu                # Show completion menu on a successive tab press.
setopt auto_param_slash         # If completed parameter is a directory, add a trailing slash.
setopt auto_pushd               # cd acts as pushd
setopt brace_ccl                # for character ranges like {a-z}
setopt chase_links              # cd into link resolves link
setopt check_jobs notify        # automatic job reporting
setopt complete_aliases         # allow original command completion within alias
setopt complete_in_word         # enable tab completion from any characters in a word
setopt extended_glob            # required for various scripts in this file and otherwise
setopt hist_expire_dups_first   # sharing/appending will result in dups
setopt hist_ignore_dups         # don't push lines identical to the previous
setopt hist_ignore_space        # don't push lines beginning with spaces
setopt ksh_typeset              # treat `local x=$(cmd)` and `local x="$(cmd)"` the same
setopt no_beep
setopt no_match                 # error on bad tab-complete
setopt path_dirs                # Perform path search even on command names with slashes.
setopt rc_quotes                # 'it''s okay' becomes "it's okay"
unsetopt flow_control           # Disable start/stop characters in shell editor.
unsetopt menu_complete          # Do not autoselect the first completion entry.

if [ "$SHLVL" -le 1 ] && [ "$TERM" = "${TERM#screen}" ] && [ "$TERM" = "${TERM#tmux}" ]; then
    if (( $+commands[tmux] )); then
        # create a new session called "what" or attach if it already exists
        LANG="en_US.UTF-8" TZ=":/etc/localtime" tmux new -A -s what && exit
        printf '\e[91m\ntmux died (%i), continuing...\n\e[0m\n' $?
    fi
fi

autoload -U zmv
autoload -U zrecompile
autoload -Uz zcalc
autoload edit-command-line
autoload history-search-end
zmodload zsh/mathfunc

echo START.SH

function {
    local a b

    [ -s ~/.sh.sha1 ] && read -r b < ~/.sh.sha1
    ( cd ~/sh \
      && print -l '#!/usr/bin/env false' '[ "${SOURCING:-0}" -gt 0 ] || exit 1' '' \
      | cat - $(grep -lF 'YES_ZSH' *(.)) \
      | tee ~/.sh \
    ) | sha1sum - \
      | cut -d' ' -f1 \
      | tee ~/.sh.sha1 \
      | read -r a

    [ "$a" = "$b" ] && touch ~/.sh.zwc || zrecompile -p ~/.sh
}

SOURCING=$((SOURCING+1))
. ~/.sh
SOURCING=$((SOURCING-1))

echo FINISH.SH

local fuzzy=`has fzy || print`

dirprev() {
    pushd -q +1
    zle reset-prompt
    precmd
}
dirnext() {
    pushd -q -0
    zle reset-prompt
    precmd
}
dirup() {
    cd ..
    zle reset-prompt
    precmd
}
dirview() {
    print
    if [ -n "$fuzzy" ]; then
        local d="$(dirs -pl | awk '!seen[$0]++' | "$fuzzy")"
        cd "$d"
    else
        # TODO: print under prompt if possible,
        # truncate and columnize
        dirs -v
    fi
    zle reset-prompt
    precmd
}

for x (dirprev dirnext dirup dirview) zle -N $x

bindkey -e # emacs-style keybinds

# oh thank god: http://blog.samsonis.me/2013/12/bash-like-history-search-functionality-for-zsh/
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey '^[[A' history-beginning-search-backward-end # up
bindkey '^[[B' history-beginning-search-forward-end # down
bindkey '^[OA' history-beginning-search-backward-end # up
bindkey '^[OB' history-beginning-search-forward-end # down

bindkey '^[[3~' delete-char # del

bindkey '^[[1;5D' emacs-backward-word # ctrl+left
bindkey '^[[1;5C' emacs-forward-word # ctrl+right
bindkey '^[[1;3D' dirprev # alt+left
bindkey '^[[1;3C' dirnext # alt+right
bindkey '^[[1;3A' dirup # alt+up
bindkey '^[[1;3B' dirview # alt+down
bindkey -s '^[s' '^Asudo ^E' # alt+s

bindkey -s '^[[6;2~' '\a' # shift+PgDn, do nothing, already at bottom (tmux)

# these binds were meant to prevent erroneous inputs from
# inputting anything, but they don't work for some reason:
#bindkey -s '^[[3;5~' '\a' # ctrl+del
#bindkey -s '^[[5;5~' '\a' # ctrl+PgUp
#bindkey -s '^[[6;5~' '\a' # ctrl+PgDn
#bindkey -s '^[[5;6~' '\a' # ctrl+shift+PgUp
#bindkey -s '^[[6;6~' '\a' # ctrl+shift+PgDn
#bindkey -s '^[[2;3~' '\a' # alt+ins
#bindkey -s '^[[3;3~' '\a' # alt+del
#bindkey -s '^[[5;3~' '\a' # alt+PgUp
#bindkey -s '^[[6;3~' '\a' # alt+PgDn
#bindkey -s '^[[1;6q' '\a' # ctrl+shift+1
#bindkey -s '^[[1;6s' '\a' # ctrl+shift+3
#bindkey -s '^[[1;6t' '\a' # ctrl+shift+4
#bindkey -s '^[[1;6u' '\a' # ctrl+shift+5
#bindkey -s '^[[1;6w' '\a' # ctrl+shift+7
#bindkey -s '^[[1;6x' '\a' # ctrl+shift+8
#bindkey -s '^[[1;6y' '\a' # ctrl+shift+9
#bindkey -s '^[[1;6l' '\a' # ctrl+shift+comma
#bindkey -s '^[[1;6n' '\a' # ctrl+shift+period
#bindkey -s '^[[1;7A' '\a' # ctrl+alt+arrow
#bindkey -s '^[[1;7B' '\a' # ctrl+alt+arrow
#bindkey -s '^[[1;7C' '\a' # ctrl+alt+arrow
#bindkey -s '^[[1;7D' '\a' # ctrl+alt+arrow
#bindkey -s '^[[1;8A' '\a' # ctrl+alt+shift+arrow
#bindkey -s '^[[1;8B' '\a' # ctrl+alt+shift+arrow
#bindkey -s '^[[1;8C' '\a' # ctrl+alt+shift+arrow
#bindkey -s '^[[1;8D' '\a' # ctrl+alt+shift+arrow

zle -N edit-command-line # new widget of the same function name
bindkey '^Xe' edit-command-line # ctrl+x -> e

echo START.-
. ~/.-shrc
echo FINISH.-

alias -g OMFG="1>/dev/null"
alias -g STFU="2>/dev/null"
alias -g WHOA='${whoa[@]}'
alias -g WELP='${welp[@]}'

alias sc="~/sh/sc" # only runs in bash (for now), so be explicit with path
alias pl="print -l" # not in -shrc because this only makes sense with zsh

function tw() { # needs the "function" keyword or else zsh complains
    twitch "$@" OMFG STFU &
}

local host="${(L)HOST}"

function {
    local t="${TERM%%-*}"
    if [ "$t" = xterm ] || [ "$t" = screen ] || [ "$t" = tmux ]; then
        # set window title
        if [ "$t" = tmux ]; then
            # don't include host, tmux prepends it
            precmd() { print -Pn "\e]2;%~\a" }
        else
            precmd() { print -Pn "\e]2;%M: %~\a" }
        fi
    else
        # act dumb
        precmd() {}
        PROMPT="%# "
        return
    fi

    # zsh adds a % symbol to newline-less output, so my bash prompt is overkill
    # NOTE: i've started hardcoding escapes instead of relying on zsh
    #       because detecting terminal features is too troublesome.
    local s=$'\x1B\x5B' # start escape code
    local e=m           #   end escape code
    local reset="${s}0${e}"
    local good=42 # green
    local  bad=41 # red

    [ "$host" = neobanshee ] && good=46 # cyan
    [ "$host" = spectre ]    && good=47 # white
    [ "$host" = wraith ]     && good=43 # yellow
    [ "$host" = sabotage ]   && good=45 # magenta

    # NOTE: i had ${s}10${e} here before, is it still necessary?
    PROMPT="%{$reset${s}%(?.${good}.${bad})${e}${s}97${e}%}%#%{$reset%} "
}

reload() {
    # initctl has a "reload" symlink, but i'm already too used to typing this.
    # to remedy this, when args are passed, invoke initctl instead.
    if [ $# -gt 0 ]; then
        "${commands[reload]:?initctl is missing}" "$@"
        return $?
    fi

    # this doesn't seem to help with _vim_files errors, eh.
    # you wanna rm .zcompdump first, then exit. that's why!
    cd ~
    if [ $? -eq 0 ]; then
        [ -f .zshrc ] && zrecompile -p .zshrc
        [ -f .prezto-compinit ] && zrecompile -p .prezto-compinit
        rm -f .zcompdump .zshrc.zwc.old .zcompdump.zwc.old
    fi
    exec zsh # reload shell, inheriting environment
}

#zmodload zsh/complist               # need all this
#autoload -Uz compinit && compinit   # just for compdef
#compdef wat=which

# generated by dircolors with https://github.com/isene/LS_COLORS
function {
    local lsc= line=
    < ~/.ls_colors | tr -d $'\r' | while read -r line; do
        lsc+="$line:"
    done
    export LS_COLORS="$lsc"
}

for x in ack cd cp ebuild gcc gist grep ln man mkdir mv rm
    alias $x="nocorrect $x"
for x in ai arith curl fc find ftp hex history let locate rsync scp sftp tw twitch wget youtube-dl yt ytg
    alias $x="noglob $x"
unset x

echo START.COMPINIT
. ~/.prezto-compinit
echo FINISH.COMPINIT
