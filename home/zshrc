setopt extended_glob

local host="${(L)HOST}"
fpath=(~/sh $fpath)

function {
    local f
    for f in ~/sh/^([_.]*)(N^/:t); do
        if [[ "$f" == fasd ]]; then
            emulate sh -c "autoload -U $f"
        else
            autoload -Uz $f
        fi
    done

    zsc() {
        local s=$1; shift
        zstyle ':completion:*'$s $@
    }
    zsc '*:default' list-colors ''
    zsc '*' completer _complete _ignored _match _correct _approximate _prefix
    zsc '*:approximate:*' max-errors 'reply=($((($#PREFIX+$#SUFFIX)/3)))'
    #zsc '*:corrections' format '%B%d (errors %e)%b'
    zsc '*:default' list-prompt '%S%M matches%s'
    zsc '*:default' menu select=0
    zsc '*' ignore-parents parent pwd
    zsc '*' ignored-patterns '*?.sw[po]' '*?.pyc' '__pycache__'
    zsc '*:*:rm:*:*' ignored-patterns
    # matching: try exact, case insensitive, then partial word completion.
    # ** for recursive, i think
    zsc '*' matcher-list 'm:{[:lower:]}={[:upper:]}' 'r:|[._-]=** r:|=**'
    # caching, for huge lists eg. package managers
    zsc '*' use-cache on
    zsc '*' cache-path ~/.zsh/cache
    # when listing completions, show type names and group by them
    zsc '*:descriptions' format "$fg_bold[black]Â» %d$reset_color"
    zsc '*' group-name ''
}

autoload -Uz compinit
compinit

HISTFILE=~/.histfile
HISTSIZE=99999
SAVEHIST=99999

function {
    local -a opts
    opts=( no_beep
        append_history share_history # across sessions
        hist_expire_dups_first # sharing/appending will result in dups
        hist_ignore_dups # don't push lines identical to the previous
        hist_ignore_space # don't push lines beginning with spaces
        auto_cd # exec a dir to cd
        auto_pushd # cd acts as pushd
        no_match # error on bad tab-complete
        check_jobs notify # automatic job reporting
        chase_links # cd into link resolves link
        complete_aliases # allow original command completion within alias
        complete_in_word # enable tab completion when cursor between words
        rc_quotes # 'you''re dumb' like "you're dumb"
        brace_ccl # for character ranges like {a-z}
        ksh_typeset # treat `local x=$(cmd)` and `x=$(cmd)` the same
    )
    setopt "${opts[@]}"
}

autoload -U zmv

zmodload zsh/mathfunc
autoload -Uz zcalc

DIRSTACKSIZE=24
dirprev() {
    pushd -q +1
    zle reset-prompt
    precmd
}
dirnext() {
    pushd -q -0
    zle reset-prompt
    precmd
}
dirup() {
    cd ..
    zle reset-prompt
    precmd
}
dirview() {
    # TODO: print under prompt if possible,
    # truncate and columnize
    print
    dirs -v
    zle reset-prompt
}

for x (dirprev dirnext dirup dirview) zle -N $x

bindkey -e # emacs-style keybinds

# oh thank god: http://blog.samsonis.me/2013/12/bash-like-history-search-functionality-for-zsh/
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey '^[[A' history-beginning-search-backward-end # up
bindkey '^[[B' history-beginning-search-forward-end # down
bindkey '^[OA' history-beginning-search-backward-end # up
bindkey '^[OB' history-beginning-search-forward-end # down

bindkey '^[[3~' delete-char

bindkey ';5D' emacs-backward-word # ctrl+left
bindkey ';5C' emacs-forward-word # ctrl+right
bindkey ';3D' dirprev # alt+left
bindkey ';3C' dirnext # alt+right
bindkey ';3A' dirup # alt+up
bindkey ';3B' dirview # alt+down
# we type a space (and delete it afterwards) to force ^Y to yank from ^U
#bindkey -s ';3A' ' ^Ucd ..^M^Y^H' # alt+up
bindkey -s '^[s' '^Asudo ^E' # alt+s

bindkey -s '^[[6;2~' '\a' # shift+PgDn, do nothing, already at bottom (tmux)

autoload edit-command-line
zle -N edit-command-line # new widget of the same function name
bindkey '^Xe' edit-command-line # ctrl+x -> e

. ~/.-shrc

alias -g OMFG="1>/dev/null"
alias -g STFU="2>/dev/null"
alias -g WHOA='${whoa[@]}'
alias -g WELP='${welp[@]}'

wipe() {
    clear
    clear # twice because mintty is weird
    echo "\e[30m\e[107m"
    printf "*%.0s" {1..$COLUMNS}
    echo "\e[0m\n"
}

for x in ack cd cp ebuild gcc gist grep ln man mkdir mv rm
    alias $x="nocorrect $x"
for x in arith hex curl fc find ftp history let locate rsync scp sftp wget twitch yt ytg ai
    alias $x="noglob $x"
unset x

alias sc="~/sh/sc" # only runs in bash (for now), so be explicit with path
alias pl="print -l" # not in -shrc because this only makes sense with zsh

tw() {
    twitch "$@" OMFG STFU &
}

if [[ "$TERM" = xterm* ]]; then
    # set window title
    precmd() { print -Pn "\e]2;%M: %~\a" }
fi

# note: zsh adds a % symbol to newline-less output, so bash prompt is overkill
function {
    local good='green'
    [[ "$host" == neobanshee ]] && good='cyan'
    [[ "$host" == spectre ]] && good='white'
    [[ "$host" == wraith ]] && good='yellow'
    [[ "$host" == sabotage ]] && good='magenta'
    PROMPT='%{'$'\e''[10m%}%b%(?.%K{'"$good"'}.%K{red})%15F%#%f%k '
    RPROMPT='%8F%h%b'
}

TIMEFMT=$'\e[93m%*U/%*E cpu/real (%P), %MM mem:\e[36m %J\e[0m'

reload() {
    # this doesn't seem to help with _vim_files errors, eh.
    # you wanna rm .zcompdump first, then exit. that's why!
    cd ~
    autoload -U zrecompile
    [ -f .zshrc ] && zrecompile -p .zshrc
    rm -f .zcompdump
    [ -f .zshrc.zwc.old ] && rm -f .zshrc.zwc.old
    [ -f .zcompdump.zwc.old ] && rm -f .zcompdump.zwc.old
    exec zsh # reload shell, inheriting environment
}

if [[ "$host" == "spectre" ]] || [[ "$host" == *"banshee" ]]; then
    # via https://github.com/whjvenyl/fasd
    if [ ! -s "$HOME/.fasd_init" ]; then
        # note that posix-alias defines aliases for the following:
        # a s d f sd sf z zz
        fasd --init \
          posix-alias \
          zsh-hook zsh-ccomp zsh-ccomp-install \
          zsh-wcomp zsh-wcomp-install \
          >| "$HOME/.fasd_init"
    fi
    source "$HOME/.fasd_init"
    alias v="f -e $EDITOR"
fi
