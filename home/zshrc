setopt extended_glob

fpath=(~/sh $fpath)

function {
    local f
    for f in ~/sh/^([_.]*)(N^/:t); do
        autoload -Uz $f
    done

    zsc() {
        local s=$1; shift
        zstyle ':completion:*'$s $@
    }
    zsc '*:default' list-colors ''
    zsc '*' completer _complete _ignored _match _correct _approximate _prefix
    zsc '*:approximate:*' max-errors 'reply=($((($#PREFIX+$#SUFFIX)/3)))'
    #zsc '*:corrections' format '%B%d (errors %e)%b'
    zsc '*:default' list-prompt '%S%M matches%s'
    zsc '*:default' menu select=0
    zsc '*' ignore-parents parent pwd
    zsc '*' ignored-patterns '*?.sw[po]' '*?.pyc' '__pycache__'
    zsc '*:*:rm:*:*' ignored-patterns
    # matching: try exact, case insensitive, then partial word completion.
    # ** for recursive, i think
    zsc '*' matcher-list 'm:{[:lower:]}={[:upper:]}' 'r:|[._-]=** r:|=**'
    # caching, for huge lists eg. package managers
    zsc '*' use-cache on
    zsc '*' cache-path ~/.zsh/cache
    # when listing completions, show type names and group by them
    zsc '*:descriptions' format "$fg_bold[black]Â» %d$reset_color"
    zsc '*' group-name ''
}

autoload -Uz compinit
compinit

HISTFILE=~/.histfile
HISTSIZE=10000
SAVEHIST=10000

function {
    local -a opts
    opts=( no_beep
        append_history share_history # across sessions
        hist_expire_dups_first # sharing/appending will result in dups
        hist_ignore_dups # don't push lines identical to the previous
        auto_cd # exec a dir to cd
        auto_pushd # cd acts as pushd
        no_match # error on bad tab-complete
        check_jobs notify # automatic job reporting
        chase_links # cd into link resolves link
        complete_aliases # allow original command completion within alias
        complete_in_word # enable tab completion when cursor between words
        rc_quotes # 'you''re dumb' like "you're dumb"
        brace_ccl # for character ranges like {a-z}
    )
    setopt "${opts[@]}"
    unsetopt rm_star_silent rm_star_wait # yolo
}

zmodload zsh/mathfunc
autoload -Uz zcalc

# consts are 2^-22 and 2^-21 which are simply representable in IEEE 754 floats
zsh_math_func_slope() {
    (( (f($1 + 0.000000238418579) - f($1 - 0.000000238418579))/0.000000476837158 ))
}

zsh_math_func_newton() {
    local i y=${1:-0}
    for ((i=0; i<${2:-8}; i++)); do
        (( y -= f(y)/slope(y) )) || return 1
    done
    (( y ))
}

zsh_math_func_newton2() {
    local i x y=${1:-0} d=999999999 p=$(( 2**-${2:-32} ))
    for ((i=0; i<32; i++)); do
        (( x = y ))
        (( y -= f(y)/slope(y) ))
        (( $d < (d = abs(x - y)) )) && {
            echo 'error: diverging, no solution' >&2
            return
        }
        (( d < p )) && break
    done
    [ $i -eq 32 ] \
    && echo "warning: didn't hit precision limit" >&2 \
    || echo "iterations: $i" >&2
    (( y ))
}

functions -M slope 1 1 zsh_math_func_slope
functions -M newton 0 2 zsh_math_func_newton
functions -M newton2 0 2 zsh_math_func_newton2

DIRSTACKSIZE=24
dirprev() {
    pushd -q +1
    zle reset-prompt
    precmd
}
dirnext() {
    pushd -q -0
    zle reset-prompt
    precmd
}
dirup() {
    cd ..
    zle reset-prompt
    precmd
}
dirview() {
    # TODO: print under prompt if possible,
    # truncate and columnize
    print
    dirs -v
    zle reset-prompt
}

for x (dirprev dirnext dirup dirview) zle -N $x

bindkey -e # emacs-style keybinds
bindkey '^[[A' history-search-backward # up
bindkey '^[[B' history-search-forward # down
bindkey ';5D' emacs-backward-word # ctrl+left
bindkey ';5C' emacs-forward-word # ctrl+right
bindkey ';3D' dirprev # alt+left
bindkey ';3C' dirnext # alt+right
bindkey ';3A' dirup # alt+up
bindkey ';3B' dirview # alt+down
# we type a space (and delete it afterwards) to force ^Y to yank from ^U
#bindkey -s ';3A' ' ^Ucd ..^M^Y^H' # alt+up
bindkey -s '^[s' '^Asudo ^E' # alt+s

autoload edit-command-line
zle -N edit-command-line # new widget of the same function name
bindkey '^Xe' edit-command-line # ctrl+x -> e

. ~/shrc.zsh

alias -g STFU="2>/dev/null"

for x in ack cd cp ebuild gcc gist grep ln man mkdir mv rm
    alias $x="nocorrect $x"
for x in arith curl fc find ftp history let locate rsync scp sftp wget
    alias $x="noglob $x"

if [[ "$TERM" = xterm* ]]; then
    precmd() { print -Pn "\e]2;%M: %~\a" }
fi

# note: zsh adds a % symbol to newline-less output, so bash prompt is overkill
PROMPT='%{'$'\e''[10m%}%b%(?.%K{green}.%K{red})%15F%#%f%k '
RPROMPT='%8F%h%b'

reload() {
    # This doesn't seem to help with _vim_files errors, ehh
    # you wanna rm .zcompdump then exit, that's why
    cd ~
    autoload -U zrecompile
    [ -f .zshrc ] && zrecompile -p .zshrc
    rm -f .zcompdump
    [ -f .zshrc.zwc.old ] && rm -f .zshrc.zwc.old
    [ -f .zcompdump.zwc.old ] && rm -f .zcompdump.zwc.old
    exec zsh # reload shell, inheriting environment
}

unset x
