#!/usr/bin/env sh
# compat: +ash +bash +dash -hush +zsh

__recolor_install() {
    ForegroundColour() { recolor RAW 10 "$@"; }
    BackgroundColour() { recolor RAW 11 "$@"; }
        CursorColour() { recolor RAW 12 "$@"; }
               Black() { recolor      0 "$@"; }
           BoldBlack() { recolor      8 "$@"; }
                 Red() { recolor      1 "$@"; }
             BoldRed() { recolor      9 "$@"; }
               Green() { recolor      2 "$@"; }
           BoldGreen() { recolor     10 "$@"; }
              Yellow() { recolor      3 "$@"; }
          BoldYellow() { recolor     11 "$@"; }
                Blue() { recolor      4 "$@"; }
            BoldBlue() { recolor     12 "$@"; }
             Magenta() { recolor      5 "$@"; }
         BoldMagenta() { recolor     13 "$@"; }
                Cyan() { recolor      6 "$@"; }
            BoldCyan() { recolor     14 "$@"; }
               White() { recolor      7 "$@"; }
           BoldWhite() { recolor     15 "$@"; }
}

__recolor() {
    tmuxy=false screeny=false linuxy=false
    case ${TERM:?} in
    (tmux*) tmuxy=true;;
    (screen*) tmuxy=true screeny=true;;
    (linux*) linuxy=true;;
    esac

    # tmux might claim to be screen, try to handle that:
    [ "${TMUX+-}" ] || [ "${SSH_TTY+-}" ] || tmuxy=false

    pre='\033]'
    post='\033\\'
    if $tmuxy; then
        : # change nothing; only color the pane this command was run in.
        # see: https://man.archlinux.org/man/tmux.1.en#allow-passthrough
        #pre='\033Ptmux;\033'"$pre"
        #post='\007'"$post"
    elif $screeny; then
        pre='\033P\033'"$pre"
        post='\007'"$post"
    fi

    malarg() {
        printf >&2 '%s: malformed argument #%s: %s\n' "$@"
        exit 2
    }

    is_a_byte() {
        [ "$1" -ge 0 ] && [ "$1" -le 255 ]
    } 2>&-

    valid_rex() {
        case $1 in
        ([0-9a-f][0-9a-f]/[0-9a-f][0-9a-f]/[0-9a-f][0-9a-f]) true;;
        (*) false;;
        esac
    }

    apply() {
        is_a_byte "$1" || malarg apply 1 "$1"
        valid_rex "$2" || malarg apply 2 "$2"
        if $linuxy; then
            set -- "$1" "${2%/*}" "${2##*/}"
            set -- "$1" "${2%%/*}" "${2##*/}" "$3"
            [ "$1" -ge 16 ] || printf '\033]P%x%s%s%s' "$@"
        else
            printf "${pre}4;%s;rgb:%s${post}" "$1" "$2"
        fi
    }

    apply_raw() {
        is_a_byte "$1" || malarg apply_raw 1 "$1"
        valid_rex "$2" || malarg apply_raw 2 "$2"
        if $linuxy; then
            : # unsupported
        else
            printf "${pre}%s;rgb:%s${post}" "$1" "$2"
        fi
    }

    split_hex() {
        # use blue channel as a temporary variable.
        b="${c%??}" r="${b%??}" g="${b#??}" b="${c#????}"
    }

    c_to_hex() { # in-place, hardcoded to use $c
        if [ "$ZSH_VERSION" ] || [ "$BASH_VERSION" ]; then
            printf -v c %02x "$c" # also supported by ksh and osh
        else
            c="$(printf %02x "$c")"
        fi
    }

    n= r=ff g=ff b=ff a= c= i= raw=false

    if [ "$1" = RAW ]; then raw=true; shift; fi
    n="$1"

    is_a_byte "$n" || malarg recolor 1 "$c"

    if c="${2#\#}"; [ "$c" != "$2" ]; then # handle #ABCDEF
        [ ${#c} = 6 ] || malarg recolor 2 "$2"
        v_lower c && split_hex || return

    elif c="${2#0x}"; [ "$c" != "$2" ] && [ ${#c} = 6 ]; then # handle 0xABCDEF
        v_lower c && split_hex || return

    else # arguments like 10 20 120, some with 0x prefixes (does not handle #)
        i=1 # NOT off by one!
        for a in "$2" "$3" "$4"; do
            : $((i+=1)) # start with the second argument (as does the for loop)
            if c="${a#0x}"; [ "$c" = "$a" ]; then # handle no hex prefix case
                is_a_byte "$c" || malarg recolor $i "$c"
                c_to_hex
            fi

            [ ${#c} != 1 ] || c="0$c" # pad to two digits
            [ ${#c} = 2 ] || malarg recolor $i "$c"
            v_lower c || return
            case $i in
            (2) r="$c";;
            (3) g="$c";;
            (4) b="$c";;
            esac
        done
    fi

    if $raw; then
        apply_raw "$n" "$r/$g/$b"
    else
        apply "$n" "$r/$g/$b"
        #if [ "$n" -eq 21 ]; then
        #    # use base16 "Bright White" for foreground as well.
        #    apply_raw 10 "$r/$g/$b"
        #fi
    fi
} >/dev/tty

recolor()(__recolor "$@")
[ -n "${preload+-}" ] || . ~/sh/preload || exit 2
eval ${preload:-preload} v_lower v_upper
[ -n "${preload+-}" ] || __recolor "$@"
