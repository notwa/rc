# this script might not be running in an interactive shell.
# do not attempt to use aliases, /dev/tty, stdin or stdout.

# most POSIX shells (that aren't trying to be bash or zsh)
# will likely source /etc/profile, followed by ~/.profile.
# then, interactive shells should source the file at $ENV.

# bash will ONLY source the first readable file of:
# ~/.bash_profile and ~/.bash_login and ~/.profile.
# zsh requires sh emulation and won't source these.

# i suggest sourcing this file from both ~/.zprofile and ~/.bash_profile.
# in doing so, most login-related setup is consolidated to a single file.

prepend() { # read permissions for PATH directories are not strictly necessary
    [ -d "$1" ] && [ -x "$1" ] || return 0
    case :${PATH-}: in (*":$1:"*) false; esac && PATH="$1${PATH:+:}${PATH-}"
}
if [ -z "${PATH-}" ] || ! command -v sh >&-; then
    [ /bin -ef /usr/bin ] || prepend /bin
    [ /sbin -ef /bin ] || [ /sbin -ef /usr/sbin ] || prepend /sbin
    prepend /usr/bin
    [ /usr/sbin -ef /usr/bin ] || prepend /usr/sbin
    prepend /usr/local/bin
    [ /usr/local/sbin -ef /usr/local/bin ] || prepend /usr/local/sbin
fi
export PATH

# this handles the case where $USER and $HOME are not set,
# as that occurs when env -i or cloud-init are being used.
# really, this code would make more sense in /etc/profile.
__pwd="$PWD"
user() { ! case ${USER=} in (*[!A-Za-z0-9._-]*) true;; (?*) false; esac; }
if ! user; then
    USER="$(whoami 2>&-)" &&
    user || unset USER # well, we tried
fi; unset -f user
home() { [ "${HOME=}" != "${HOME#/}" ] && cd -- "$HOME" 2>&-; }
if ! home; then
    for HOME in /root "${USER+/home/}${USER-}" /home/* ""; do
        [ -d "$HOME" ] && [ -O "$HOME" ] && break
    done
    home || unset HOME # well, we tried
fi; unset -f home
cd -- "$__pwd"; unset __pwd

#export LANG=$(locale -uU) # set user-defined locale
export SSH_AUTH_SOCK=0 # more info: https://0x0.st/NUnw
export TZ=':/etc/localtime' # more info: https://0x0.st/NUnv

EA_AUTH='auth' EA_DIR='t' EA_DOMAIN='https://eaguru.guru'

if case $- in (*i*) true;; (*) false;; esac; then
    # this is an interactive shell.

    # this trick with ENV works in: ash, dash, ksh, and loksh/oksh.
    # bash has $BASH_ENV, but it only runs in non-interactive mode.
    ! [ -r ~/.shrc ] || export ENV=~/.shrc
    ! [ -r ~/.bashrc ] || BASH_ENV=~/.bashrc # see ~/.bash_profile

elif [ -n "${HOME++}" ]; then
    # this is a non-interactive shell.

    prepend "$HOME/.local/bin"
    # add ~/sh/ to PATH so that those commands can be run from ssh et al.
    # TODO: consider exporting EA_* variables, so that `ea` can work too.
    prepend "$HOME/sh"
    if [ -r "$HOME/sh/zzz" ]; then
        # a script containing short functions that don't merit individual files:
        . ~/sh/zzz
    fi
fi
unset -f prepend
