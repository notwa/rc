#!/usr/bin/env zsh

emulate -L zsh
setopt ksh_typeset typeset_silent

local -A unames gnames us
while IFS=: read -rA A; do unames[${A[3]}]=${A[1]} done < /etc/passwd
while IFS=: read -rA A; do gnames[${A[3]}]=${A[1]} done < /etc/group
for x in $(groups); do us[$x]=1 done

local -a colors
colors=(bla red gre yel blu pur cya whi)
local i $=colors ${(U)=colors} clr=$'\e[0m'
for i in {0..7}; do
    local x=${colors[$((i+1))]}
    eval "$x=$'\\e[3${i}m'" "${(U)x}=$'\\e[9${i}m'"
done

local s=1 m h d y B=1 K M G T
noglob let m=60*s h=60*m d=24*h y=365*d K=1024*B M=1024*K G=1024*M T=1024*G 

local s_ft='
y*10 y BLA
y*2  y blu
y    d BLU
d*30 d cya
d*7  d CYA
d    h gre
h*12 h GRE
h    m yel
m*10 m YEL
m    s pur
0    s PUR
'

local s_fs='
T*8 T red
T   G red
G*8 G pur
G   M pur
M   M yel
M   K yel
K*8 K CYA
K   B CYA
1   B cya
0   B BLA
'

local permcolors="$BLA $WHI $yel $YEL $blu $BLU $gre $GRE"
permcolors=($=permcolors)

#                            chr       dir       blk      file       sym
local typecolors="$RED $BLA $YEL $BLA $BLU $BLA $yel $BLA $clr $BLA $CYA"
typecolors=($=typecolors)

local ft fs
local min unit color
for min unit color in $=s_ft; do
    ft+=($(($min)) $unit $color)
done
for min unit color in $=s_fs; do
    fs+=($(($min)) $unit $color)
done

_lsz_pretty() {
    local min unit color
    for min unit color in ${(P)2}; do
        [ $1 -lt $min ] && continue
        local unitified=$(($1/$unit))
        echo -n "${(P)color}${(l:4:)unitified}$clr$unit"
        break
    done
}

_lsz_min() {
    local min=99999999999 x
    for x; do [ $x -lt $min ] && min=$x; done
    echo $min
}

_lsz_max() {
    local _lsz_max=-99999999999 x
    for x; do [ $x -gt $_lsz_max ] && _lsz_max=$x; done
    echo $_lsz_max
}

_lsz_perm() {
    echo -n ${permcolors[$(($1+1))]}$1
}

_lsz_type() {
    echo -n ${typecolors[$(($1+1))]}
}

local now=$(date +%s)
_lsz_date() {
    [ $1 -lt 32 ] \
    && echo -n "$BLA  N/A$clr" \
    || _lsz_pretty $((now-$1)) ft
    echo -n ' '
}

_lsz() {
    local din=${1%/}

    local dinf=$(readlink -f ${din:-/})
    local glob=$dinf
    [ -d "$dinf" ] && glob=$dinf/*(DN)

    local count=${2:-0}
    [ $count -gt 1 ] && echo "$WHI$dinf"

    local -a matches
    matches=(${~glob})
    [ ${#matches} -eq 0 ] && return

    stat -t -- ${matches[@]} | while read -r; do
        __lsz "$REPLY" "$dinf"
    done
}

__lsz() {
    local A dinf=$2
    read -rA A <<<$1

    local uid=${A[-12]} gid=${A[-11]} is_me=0 is_us=0
    local uname=${unames[$uid]} gname=${gnames[$gid]}
    [ $uid -eq $UID ] && is_me=1
    [ -n "$gname" ] && [[ ${us[$gname]} -eq 1 ]] && is_us=1

    local bits type uperm gperm operm our_perm
    bits=$((16#${A[-13]}))
    let 'type=(bits & 8#170000) >> 12'
    let 'uperm=(bits & 8#700) >> 6'
    let 'gperm=(bits & 8#70) >> 3'
    let 'operm=bits & 8#7'
    let 'our_perm=(is_me?uperm:0) | (is_us?gperm:0) | operm'

    case $type in
        2)  echo -n '    c' ;;
        6)  echo -n '    b' ;;
        4)  echo -n '    /' ;;
        10) echo -n '    >' ;;
        *)  _lsz_pretty ${A[-15]} fs ;;
    esac

    true && {
        echo -n ' '
        _lsz_perm $our_perm
    }

    true && {
        echo -n ' '
        _lsz_perm $uperm
        _lsz_perm $gperm
        _lsz_perm $operm
    }

    echo -n "$clr"

    local da=${A[-5]} dc=${A[-4]} dm=${A[-3]}
    true && {
        _lsz_date $da
        _lsz_date $dm
        _lsz_date $dc
    } || {
        _lsz_date $(_lsz_max $da $dc $dm)
    }

    local n=${A[1,-16]}
    n=${n##$dinf/}
    _lsz_type $type
    echo $n$clr
}

local f
[ ${#@} -eq 0 ] && set -- $PWD
for f; _lsz $f ${#@}
