setopt extended_glob

fpath=(~/sh $fpath)

function {
    local f
    for f in ~/sh/^([_.]*)(N^/:t); do
        autoload -Uz $f
    done

    zsc() {
        local s=$1; shift
        zstyle ':completion:*'$s $@
    }
    zsc '*:default' list-colors ''
    zsc '*' completer _complete _ignored _match _correct _approximate _prefix
    zsc '*:approximate:*' max-errors 'reply=($((($#PREFIX+$#SUFFIX)/3)))'
    #zsc '*:corrections' format '%B%d (errors %e)%b'
    zsc '*:default' list-prompt '%S%M matches%s'
    zsc '*:default' menu select=0
    zsc '*' ignore-parents parent pwd
    zsc '*' ignored-patterns '*?.sw[po]' '*?.pyc' '__pycache__'
    zsc '*:*:rm:*:*' ignored-patterns
    # matching: try exact, case insensitive, then partial word completion.
    # ** for recursive, i think
    zsc '*' matcher-list 'm:{[:lower:]}={[:upper:]}' 'r:|[._-]=** r:|=**'
    # caching, for huge lists eg. package managers
    zsc '*' use-cache on
    zsc '*' cache-path ~/.zsh/cache
    # when listing completions, show type names and group by them
    zsc '*:descriptions' format "$fg_bold[black]Â» %d$reset_color"
    zsc '*' group-name ''
}

autoload -Uz compinit
compinit

HISTFILE=~/.histfile
HISTSIZE=16384
SAVEHIST=16384

function {
    local -a opts
    opts=( no_beep
        append_history share_history # across sessions
        hist_expire_dups_first # sharing/appending will result in dups
        hist_ignore_dups # don't push lines identical to the previous
        hist_ignore_space # don't push lines beginning with spaces
        auto_cd # exec a dir to cd
        auto_pushd # cd acts as pushd
        no_match # error on bad tab-complete
        check_jobs notify # automatic job reporting
        chase_links # cd into link resolves link
        complete_aliases # allow original command completion within alias
        complete_in_word # enable tab completion when cursor between words
        rc_quotes # 'you''re dumb' like "you're dumb"
        brace_ccl # for character ranges like {a-z}
        ksh_typeset # treat `local x=$(cmd)` and `x=$(cmd)` the same
    )
    setopt "${opts[@]}"
    unsetopt rm_star_silent rm_star_wait # yolo
}

autoload -U zmv

zmodload zsh/mathfunc
autoload -Uz zcalc

DIRSTACKSIZE=24
dirprev() {
    pushd -q +1
    zle reset-prompt
    precmd
}
dirnext() {
    pushd -q -0
    zle reset-prompt
    precmd
}
dirup() {
    cd ..
    zle reset-prompt
    precmd
}
dirview() {
    # TODO: print under prompt if possible,
    # truncate and columnize
    print
    dirs -v
    zle reset-prompt
}

for x (dirprev dirnext dirup dirview) zle -N $x

bindkey -e # emacs-style keybinds

# oh thank god: http://blog.samsonis.me/2013/12/bash-like-history-search-functionality-for-zsh/
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey '^[[A' history-beginning-search-backward-end # up
bindkey '^[[B' history-beginning-search-forward-end # down
bindkey '^[OA' history-beginning-search-backward-end # up
bindkey '^[OB' history-beginning-search-forward-end # down

bindkey '^[[3~' delete-char

bindkey ';5D' emacs-backward-word # ctrl+left
bindkey ';5C' emacs-forward-word # ctrl+right
bindkey ';3D' dirprev # alt+left
bindkey ';3C' dirnext # alt+right
bindkey ';3A' dirup # alt+up
bindkey ';3B' dirview # alt+down
# we type a space (and delete it afterwards) to force ^Y to yank from ^U
#bindkey -s ';3A' ' ^Ucd ..^M^Y^H' # alt+up
bindkey -s '^[s' '^Asudo ^E' # alt+s

autoload edit-command-line
zle -N edit-command-line # new widget of the same function name
bindkey '^Xe' edit-command-line # ctrl+x -> e

. ~/.-shrc

alias -g OMFG="1>/dev/null"
alias -g STFU="2>/dev/null"

for x in ack cd cp ebuild gcc gist grep ln man mkdir mv rm
    alias $x="nocorrect $x"
for x in arith hex curl fc find ftp history let locate rsync scp sftp wget twitch hitbox yt
    alias $x="noglob $x"

if [[ "$TERM" = xterm* ]]; then
    precmd() { print -Pn "\e]2;%M: %~\a" }
fi

# note: zsh adds a % symbol to newline-less output, so bash prompt is overkill
function {
    local good='green'
    [[ "${(L)HOST}" == "banshee" ]] && good='cyan'
    [[ "${(L)HOST}" == "spectre" ]] && good='white'
    [[ "${(L)HOST}" == "wraith" ]] && good='yellow'
    PROMPT='%{'$'\e''[10m%}%b%(?.%K{'"$good"'}.%K{red})%15F%#%f%k '
    RPROMPT='%8F%h%b'
}

reload() {
    # This doesn't seem to help with _vim_files errors, ehh
    # you wanna rm .zcompdump then exit, that's why
    cd ~
    autoload -U zrecompile
    [ -f .zshrc ] && zrecompile -p .zshrc
    rm -f .zcompdump
    [ -f .zshrc.zwc.old ] && rm -f .zshrc.zwc.old
    [ -f .zcompdump.zwc.old ] && rm -f .zcompdump.zwc.old
    exec zsh # reload shell, inheriting environment
}

unset x

[ -e "/home/$USER/opt/local/bin/torch-activate" ] && \
   . "/home/$USER/opt/local/bin/torch-activate"
